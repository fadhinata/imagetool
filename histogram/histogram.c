/* Copyright 2011 Hoyoung Yi. This program is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this program; if not, please visit www.gnu.org.*/#include <stdio.h>#include <string.h>#include <math.h>#include <limits.h>#include <common.h>#include <histogram.h>#include <assert.h>int bytemap_histogram(int *hist, bytemap_t *im){  int i, j, n, w, h;  uint8_t *buf;  int pitch;	  assert(hist);  assert(im);	  memset(hist, 0, (UINT8_MAX + 1) * sizeof(*hist));  w = bytemap_get_width(im);  h = bytemap_get_height(im);  buf = bytemap_get_buffer(im);  pitch = bytemap_get_pitch(im) / sizeof(*buf);  n = 0;  for (i = 0; i < h; i++) {    for (j = 0; j < w; j++) {      hist[*(buf + j)]++;      n++;    }    buf += pitch;  }  return n;}int bytemap_histogram_on_roi(int *hist, bytemap_t *im, bitmap_t *roi){  int i, j, n, w, h;  uint8_t *buf, *roibuf;  int pitch, roipitch;  assert(hist);  assert(im);  assert(roi);  assert(bytemap_get_width(im) == bitmap_get_width(roi));  assert(bytemap_get_height(im) == bitmap_get_height(roi));  memset(hist, 0, (UINT8_MAX + 1) * sizeof(*hist));  w = bytemap_get_width(im);  h = bytemap_get_height(im);  buf = bytemap_get_buffer(im);  pitch = bytemap_get_pitch(im) / sizeof(*buf);  roibuf = bytemap_get_buffer(roi);  roipitch = bytemap_get_pitch(roi) / sizeof(*roibuf);  n = 0;  for (i = 0; i < h; i++) {    for (j = 0; j < w; j++) {      if ((*(roibuf + (j >> 3))) & (1 << (j % 8))) {	hist[*(buf + j)]++;	n++;      }    }    buf += pitch;    roibuf += roipitch;  }  return n;}int bytemap_histogram_on_region(int *hist, bytemap_t *im, int x, int y, int dx, int dy){  int i, j, n;  int width, height;  uint8_t *buf;  int pitch;  assert(hist);  assert(im);  assert(x >= 0 && x < bytemap_get_width(im));  assert(y >= 0 && y < bytemap_get_height(im));  assert(dx > 0);  assert(dy > 0);  memset(hist, 0, (UINT8_MAX + 1) * sizeof(*hist));  buf = bytemap_get_buffer(im);  pitch = bytemap_get_pitch(im) / sizeof(*buf);  n = 0;  width = min(x + dx, bytemap_get_width(im));  height = min(y + dy, bytemap_get_height(im));  for (i = y; i < height; i++) {    for (j = x; j < width; j++) {      hist[*(buf + j)]++;      n++;    }    buf += pitch;  }  return n;}void bytemap_histogram_equalize(bytemap_t *q, bytemap_t *p){  int i, j, w, h;  int hist[UINT8_MAX + 1], convert[UINT8_MAX + 1];  uint8_t *qbuf, *pbuf;  real_t sum, partsum;  int qpitch, ppitch;  assert(q);  assert(p);  assert(bytemap_get_width(q) == bytemap_get_width(p));  assert(bytemap_get_height(q) == bytemap_get_height(p));  sum = bytemap_histogram(hist, p);  for (partsum = 0.0, i = 0; i < UINT8_MAX+1; i++) {    partsum += hist[i];    convert[i] = (int)round(partsum / sum * UINT8_MAX);    //if (convert[i] < 0) convert[i] = 0;    //else if (convert[i] > UINT8_MAX) convert[i] = UINT8_MAX;  }  w = bytemap_get_width(p);  h = bytemap_get_height(p);  qbuf = bytemap_get_buffer(q);  qpitch = bytemap_get_pitch(q) / sizeof(*qbuf);  pbuf = bytemap_get_buffer(p);  ppitch = bytemap_get_pitch(p) / sizeof(*pbuf);  for (i = 0; i < h; i++) {    for (j = 0; j < w; j++) {      *(qbuf + j) = convert[*(pbuf + j)];    }    qbuf += qpitch;    pbuf += ppitch;  }}void bytemap_histogram_equalize_on_roi(bytemap_t *q, bytemap_t *p, bitmap_t *roi){  int i, j, w, h;  int hist[UINT8_MAX + 1], convert[UINT8_MAX + 1];  uint8_t *qbuf, *pbuf, *roibuf;  real_t sum, partsum;  int qpitch, ppitch, roipitch;  assert(q);  assert(p);  assert(roi);  assert(bytemap_get_width(q) == bytemap_get_width(p));  assert(bytemap_get_height(q) == bytemap_get_height(p));  assert(bitmap_get_width(roi) == bytemap_get_width(p));  assert(bitmap_get_height(roi) == bytemap_get_height(p));  w = bytemap_get_width(p);  h = bytemap_get_height(p);  sum = bytemap_histogram_on_roi(hist, p, roi);  for (partsum = 0.0, i = 0; i < UINT8_MAX+1; i++) {    partsum += hist[i];    convert[i] = (int)round(partsum / sum * UINT8_MAX);    //if (convert[i] < 0) convert[i] = 0;    //else if (convert[i] > UINT8_MAX) convert[i] = UINT8_MAX;  }  qbuf = bytemap_get_buffer(q);  qpitch = bytemap_get_pitch(q) / sizeof(*qbuf);  pbuf = bytemap_get_buffer(p);  ppitch = bytemap_get_pitch(p) / sizeof(*pbuf);  roibuf = bitmap_get_buffer(roi);  roipitch = bitmap_get_pitch(roi) / sizeof(*roibuf);  for (i = 0; i < h; i++) {    for (j = 0; j < w; j++) {      if ((*(roibuf + (j >> 3))) & (1 << (j % 8)))	*(qbuf + j) = convert[*(pbuf + j)];    }    qbuf += qpitch;    pbuf += ppitch;    roibuf += roipitch;  }}void bytemap_histogram_equalize_on_region(bytemap_t *q, bytemap_t *p, int x, int y, int dx, int dy){  int i, j;  int width, height;  int hist[UINT8_MAX+1], convert[UINT8_MAX+1];  uint8_t *qbuf, *pbuf;  real_t sum, partsum;  int qpitch, ppitch;  assert(q);  assert(p);  assert(bytemap_get_width(q) == bytemap_get_width(p));  assert(bytemap_get_height(q) == bytemap_get_height(p));  assert(x >= 0 && x < bytemap_get_width(p));  assert(y >= 0 && y < bytemap_get_height(p));  assert(dx > 0);  assert(dy > 0);	  sum = bytemap_histogram_on_region(hist, p, x, y, dx, dy);  for (partsum = 0.0, i = 0; i < UINT8_MAX+1; i++) {    partsum += hist[i];    convert[i] = (int)round(partsum / sum * UINT8_MAX);    //if (convert[i] < 0) convert[i] = 0;    //else if (convert[i] > UINT8_MAX) convert[i] = UINT8_MAX;  }  qbuf = bytemap_get_buffer(q);  qpitch = bytemap_get_pitch(q) / sizeof(*qbuf);  pbuf = bytemap_get_buffer(p);  ppitch = bytemap_get_pitch(p) / sizeof(*pbuf);  width = min(x + dx, bytemap_get_width(p));  height = min(y + dy, bytemap_get_height(p));  for (i = y; i < height; i++) {    for (j = x; j < width; j++) {      *(qbuf + j) = convert[*(pbuf + j)];    }    qbuf += qpitch;    pbuf += ppitch;  }}int wordmap_histogram(int *hist, wordmap_t *im){  int i, j, n, w, h;  uint16_t *buf;  int pitch;	  assert(hist);  assert(im);	  memset(hist, 0, (UINT16_MAX + 1) * sizeof(*hist));  w = wordmap_get_width(im);  h = wordmap_get_height(im);  buf = wordmap_get_buffer(im);  pitch = wordmap_get_pitch(im) / sizeof(*buf);  n = 0;  for (i = 0; i < h; i++) {    for (j = 0; j < w; j++) {      hist[*(buf + j)]++;      n++;    }    buf += pitch;  }  return n;}int wordmap_histogram_on_roi(int *hist, wordmap_t *im, bitmap_t *roi){  int i, j, n;  uint16_t *buf;  uint8_t *roibuf;  int w, h, pitch, roipitch;  assert(hist);  assert(im);  assert(roi);  assert(wordmap_get_width(im) == bitmap_get_width(roi));  assert(wordmap_get_height(im) == bitmap_get_height(roi));  memset(hist, 0, (UINT16_MAX + 1) * sizeof(*hist));  w = wordmap_get_width(im);  h = wordmap_get_height(im);  buf = wordmap_get_buffer(im);  pitch = wordmap_get_pitch(im) / sizeof(*buf);  roibuf = bitmap_get_buffer(roi);  roipitch = bitmap_get_pitch(roi) / sizeof(*roibuf);    n = 0;  for (i = 0; i < h; i++) {    for (j = 0; j < w; j++) {      if ((*(roibuf + (j >> 3))) & (1 << (j % 8))) {	hist[*(buf + j)]++;	n++;      }    }    buf += pitch;    roibuf += roipitch;  }  return n;}int wordmap_histogram_on_region(int *hist, wordmap_t *im, int x, int y, int dx, int dy){  int i, j, n, w, h;  int width, height;  uint16_t *buf;  int pitch;	  assert(hist);  assert(im);  assert(x >= 0 && x < wordmap_get_width(im));  assert(y >= 0 && y < wordmap_get_height(im));  assert(dx > 0);  assert(dy > 0);  memset(hist, 0, (UINT16_MAX + 1) * sizeof(*hist));  w = wordmap_get_width(im);  h = wordmap_get_height(im);  buf = wordmap_get_buffer(im);  pitch = wordmap_get_pitch(im) / sizeof(*buf);  n = 0;  width = min(x + dx, w);  height = min(y + dy, h);  for (i = y; i < height; i++) {    for (j = x; j < width; j++) {      hist[*(buf + j)]++;      n++;    }    buf += pitch;  }  return n;}void wordmap_histogram_equalize(wordmap_t *q, wordmap_t *p){  int i, j, w, h;  int hist[UINT16_MAX + 1], convert[UINT16_MAX + 1];  uint16_t *qbuf, *pbuf;  real_t sum, partsum;  int qpitch, ppitch;  assert(q);  assert(p);  assert(wordmap_get_width(q) == wordmap_get_width(p));  assert(wordmap_get_height(q) == wordmap_get_height(p));  w = wordmap_get_width(p);  h = wordmap_get_height(p);  sum = wordmap_histogram(hist, p);  for (partsum = 0.0, i = 0; i < UINT16_MAX+1; i++) {    partsum += hist[i];    convert[i] = (int)round(partsum / sum * UINT16_MAX);    //if (convert[i] < 0) convert[i] = 0;    //else if (convert[i] > UINT16_MAX) convert[i] = UINT16_MAX;  }  qbuf = wordmap_get_buffer(q);  qpitch = wordmap_get_pitch(q) / sizeof(*qbuf);  pbuf = wordmap_get_buffer(p);  ppitch = wordmap_get_pitch(p) / sizeof(*pbuf);  for (i = 0; i < h; i++) {    for (j = 0; j < w; j++) {      *(qbuf + j) = convert[*(pbuf + j)];    }    qbuf += qpitch;    pbuf += ppitch;  }}void wordmap_histogram_equalize_on_roi(wordmap_t *q, wordmap_t *p, bitmap_t *roi){  int i, j, w, h;  int hist[UINT16_MAX + 1], convert[UINT16_MAX +1];  uint16_t *qbuf, *pbuf;  unsigned char *roibuf;  real_t sum, partsum;  int qpitch, ppitch, roipitch;  assert(q);  assert(p);  assert(roi);  assert(wordmap_get_width(q) == wordmap_get_width(p));  assert(wordmap_get_height(q) == wordmap_get_height(p));  assert(bitmap_get_width(roi) == wordmap_get_width(p));  assert(bitmap_get_height(roi) == wordmap_get_height(p));  sum = wordmap_histogram_on_roi(hist, p, roi);  for (partsum = 0.0, i = 0; i < UINT16_MAX+1; i++) {    partsum += hist[i];    convert[i] = (int)floor(partsum/sum*UINT16_MAX+0.5);    //if (convert[i] < 0) convert[i] = 0;    //else if (convert[i] > UINT16_MAX) convert[i] = UINT16_MAX;  }  w = wordmap_get_width(p);  h = wordmap_get_height(p);  qbuf = wordmap_get_buffer(q);  qpitch = wordmap_get_pitch(q) / sizeof(*qbuf);  pbuf = wordmap_get_buffer(p);  ppitch = wordmap_get_pitch(p) / sizeof(*pbuf);  roibuf = bitmap_get_buffer(roi);  roipitch = bitmap_get_pitch(roi) / sizeof(*roibuf);  for (i = 0; i < h; i++) {    for (j = 0; j < w; j++) {      if ((*(roibuf + (j >> 3))) & (1 << (j % 8)))	*(qbuf + j) = convert[*(pbuf + j)];    }    qbuf += qpitch;    pbuf += ppitch;    roibuf += roipitch;  }}void wordmap_histogram_equalize_on_region(wordmap_t *q, wordmap_t *p, int x, int y, int dx, int dy){  int i, j;  int width, height;  int hist[UINT16_MAX+1], convert[UINT16_MAX+1];  uint16_t *qbuf, *pbuf;  real_t sum, partsum;  int qpitch, ppitch;  assert(q);  assert(p);  assert(wordmap_get_width(q) == wordmap_get_width(p));  assert(wordmap_get_height(q) == wordmap_get_height(p));  assert(x >= 0 && x < wordmap_get_width(p));  assert(y >= 0 && y < wordmap_get_height(p));  assert(dx > 0);  assert(dy > 0);  sum = wordmap_histogram_on_region(hist, p, x, y, dx, dy);  for (partsum = 0.0, i = 0; i < UINT16_MAX+1; i++) {    partsum += hist[i];    convert[i] = (int)floor(partsum/sum*UINT16_MAX+0.5);    //if (convert[i] < 0) convert[i] = 0;    //else if (convert[i] > UINT16_MAX) convert[i] = UINT16_MAX;  }  qbuf = wordmap_get_buffer(q);  qpitch = wordmap_get_pitch(q) / sizeof(*qbuf);  pbuf = wordmap_get_buffer(p);  ppitch = wordmap_get_pitch(p) / sizeof(*pbuf);  width = min(x + dx, wordmap_get_width(p));  height = min(y + dy, wordmap_get_height(p));  for (i = y; i < height; i++) {    for (j = x; j < width; j++) {      *(qbuf + j) = convert[*(pbuf + j)];    }    qbuf += qpitch;    pbuf += ppitch;  }}/*  int histogram(int *hist, bytemap_t *p, bitmap_t *m)  {  int r, c, val, pixels;  unsigned char *pbuf, *mbuf = NULL;	  assert(p);  assert(hist);  memset(hist, 0, 256*sizeof(*hist));  pbuf = p->buffer;  if (m) {  assert(p->header.width == m->header.width);  assert(p->header.height == m->header.height);  mbuf = m->buffer;  }  pixels = 0;  for (r = 0; r < p->header.height; r++) {  for (c = 0; c < p->header.width; c++) {  if (mbuf) {  if (*(mbuf+(c>>3))&(1<<(c%8))) {  val = (int)*(pbuf+c);  hist[val]++;  pixels++;  }  } else {  val = (int)*(pbuf+c);  hist[val]++;  pixels++;  }			  }  pbuf += p->header.pitch;  if (mbuf) mbuf += m->header.pitch;  }  return pixels;  }  void histogram_equalize(bytemap_t *q, bytemap_t *p, bitmap_t *m)  {  int i, c, r;  int hist[256], convert[256];  unsigned char *qbuf, *pbuf;  double sum, partsum;  assert(q);  assert(p);	  sum = histogram(hist, p, m);  for (partsum = 0.0, i = 0; i < 256; i++) {  partsum += hist[i];  convert[i] = floor(partsum/sum*256.0);  if (convert[i] < 0) convert[i] = 0;  else if (convert[i] > 255) convert[i] = 255;  }  qbuf = q->buffer;  pbuf = p->buffer;  for (r = 0; r < p->header.height; r++) {  for (c = 0; c < p->header.width; c++) {  *(qbuf+c) = convert[*(pbuf+c)];  }  qbuf += q->header.pitch;  pbuf += p->header.pitch;  }  }*//*  void histogram_match(bytemap_t *c, bytemap_t *a, bytemap_t *b, bitmap_t *m)  {  bytemap_t *aa, *bb;	  assert(c);  assert(a);  assert(b);  assert(a->header.width == b->header.width && a->header.height == b->header.height);  assert(a->header.width == c->header.width && a->header.height == c->header.height);	  aa = bytemap_clone(a);  bb = bytemap_clone(b);	  histogram_equalize(aa, a, m);  histogram_equalize(bb, b, m);	  bytemap_delete(bb);  bytemap_delete(aa);  }*/